package rpc

import (
	"errors"

	"golang.org/x/net/context"
)

// Client allows calls and notifies on the given transporter, or any protocol
// type. All will share the same ErrorUnwrapper hook for unwrapping incoming
// msgpack objects and converting to possible Go-native `Error` types
type Client struct {
	xp             Transporter
	errorUnwrapper ErrorUnwrapper
	tagsFunc       LogTagsFromContext
	sendNotifier   SendNotifier
	replySequencer ReplySequencer
}

// NewClient constructs a new client from the given RPC Transporter and the
// ErrorUnwrapper.
func NewClient(xp Transporter, u ErrorUnwrapper,
	tagsFunc LogTagsFromContext) *Client {
	return &Client{xp, u, tagsFunc, nil, nil}
}

// NewClientWithSendNotifier constructs a new client from the given RPC Transporter, the
// ErrorUnwrapper, and the SendNotifier
func NewClientWithSendNotifierAndReplySequencer(xp Transporter, u ErrorUnwrapper,
	tagsFunc LogTagsFromContext, sendNotifier SendNotifier,
	replySequencer ReplySequencer) *Client {
	return &Client{xp, u, tagsFunc, sendNotifier, replySequencer}
}

// SendNotifier notifies the Caller when an RPC is released into the stream of
// messages. If, for instance, a caller wants to serialize sends to ensure some
// sort of client-side ordering, they can use this hook. Note that the hook fires
// long before the RPC is replied to. It will be called with the RPC sequence number
// that the RPC got on the way out, or SeqNumber(0) for Notify calls (which don't
// get sequence numbers).
type SendNotifier func(SeqNumber)

// ReplySequencer tells the clients what order the replies came back from the server in.
// Replies from the server will be number 0,1,2,3...., in the order in which they
// were received. This function is called to map this sequece numbering to the
// sequence number the client picket.
type ReplySequencer func(server SeqNumber, client SeqNumber)

// Call makes an msgpack RPC call over the transports that's bound to this
// client. The name of the method, and the argument are given. On reply,
// the result field will be populated (if applicable). It returns an Error
// on error, where the error might have been unwrapped from Msgpack via the
// UnwrapErrorFunc in this client.
func (c *Client) Call(ctx context.Context, method string, arg interface{}, res interface{}) (err error) {
	if ctx == nil {
		return errors.New("No Context provided for this call")
	}

	if c.tagsFunc != nil {
		tags, ok := c.tagsFunc(ctx)
		if ok {
			rpcTags := make(CtxRpcTags)
			for key, tagName := range tags {
				if v := ctx.Value(key); v != nil {
					rpcTags[tagName] = v
				}
			}
			ctx = AddRpcTagsToContext(ctx, rpcTags)
		}
	}

	c.xp.receiveFrames()
	d, err := c.xp.getDispatcher()
	if err != nil {
		return err
	}
	return d.Call(ctx, method, arg, res, c.errorUnwrapper, c.sendNotifier, c.replySequencer)
}

// Notify notifies the server, with the given method and argument. It does not
// wait to hear back for an error. An error might happen in sending the call, in
// which case a native Go Error is returned. The UnwrapErrorFunc in the underlying
// client isn't relevant in this case.
func (c *Client) Notify(ctx context.Context, method string, arg interface{}) (err error) {
	if ctx == nil {
		return errors.New("No Context provided for this notification")
	}
	d, err := c.xp.getDispatcher()
	if err != nil {
		return err
	}
	return d.Notify(ctx, method, arg, c.sendNotifier)
}

// GenericClient is the interface that is exported to autogenerated RPC stubs
// from AVDL files.
type GenericClient interface {
	Call(ctx context.Context, method string, arg interface{}, res interface{}) error
	Notify(ctx context.Context, method string, arg interface{}) error
}
